
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_source\auto_galleries\data\plot_2_feature_selection.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download__source_auto_galleries_data_plot_2_feature_selection.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__source_auto_galleries_data_plot_2_feature_selection.py:


========================================
Feature Selection
========================================

.. GENERATED FROM PYTHON SOURCE LINES 9-10

Import modeva modules

.. GENERATED FROM PYTHON SOURCE LINES 10-14

.. code-block:: Python

    import numpy as np
    import pandas as pd
    from modeva import DataSet








.. GENERATED FROM PYTHON SOURCE LINES 15-16

Load a simulated Friedman data

.. GENERATED FROM PYTHON SOURCE LINES 16-25

.. code-block:: Python

    from sklearn.datasets import make_friedman1
    x, y = make_friedman1(n_samples=10000, n_features=10, noise=0.1, random_state=2024)
    columns = ['X' + str(i) for i in range(10)] + ['Y']
    df = pd.DataFrame(np.concatenate([x, y.reshape(-1, 1)], 1), columns=columns)

    ds = DataSet()
    ds.load_dataframe(data=df)
    ds.set_random_split()








.. GENERATED FROM PYTHON SOURCE LINES 26-27

Correlation based feature selection

.. GENERATED FROM PYTHON SOURCE LINES 27-30

.. code-block:: Python

    results = ds.feature_select_corr(threshold=0.2)
    results.plot()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">

                <!DOCTYPE html>
                <html lang="en" style="height: 100%">
                <head>
                <meta charset="utf-8">
                </head>
                <body style="height: 100%; margin: 0">

            
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"></script>
            
                <div id="1737119400.1464856" style="height: 600px; width: 600px; overflow: auto"></div>
            
                <script type="text/javascript">
                var dom = document.getElementById('1737119400.1464856');
                dom.innerHTML = ""
                dom.setAttribute('_echarts_instance_', '')
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
        option = {"chart_id": "1737119400.1464856", "link_id": null, "figname": "", "title": {"show": true, "text": "Feature Selection (Correlation)", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": ["X2", "X6", "X9", "X5", "X7", "X8", "X4", "X0", "X1", "X3"], "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 40.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "type": "value", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "min": -0.2028, "max": 0.8038, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": false, "showMaxLabel": false, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "bar", "colorBy": "series", "z": 2, "legendHoverLink": true, "stack": "", "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "color": "black", "position": null, "fontSize": 12}, "itemStyle": {}, "seriesLayoutBy": "column", "data": [{"value": [0.00027501826451572457, "X2"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.0002796811878084445, "X6"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.00189931547896723, "X9"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.003767628835057246, "X5"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.0039004079659084555, "X7"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.005723060456804183, "X8"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.28175014620383554, "X4"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.3952087499581659, "X0"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.39690151489708575, "X1"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.5963145715059678, "X3"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}], "markLine": {"symbolSize": 0, "silent": true, "label": {"show": false}, "data": [{"xAxis": 0.2, "lineStyle": {"type": "dashed", "color": "red"}}]}, "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "color": "#1f77b4", "coordinateSystem": "cartesian2d", "showBackground": true, "backgroundStyle": {"color": "rgba(180, 180, 180, 0.2)"}, "barWidth": "90%", "barGap": "0", "barCategoryGap": "20%", "largeThreshold": 400, "progressive": 5000, "progressiveThreshold": 3000, "progressiveChunkMode": "mod", "orient": "horizontal", "x_value": ["X2", "X6", "X9", "X5", "X7", "X8", "X4", "X0", "X1", "X3"], "tooltip_type": "axis", "hist": false, "data_value": [["X2", "0.00027501826451572457"], ["X6", "0.0002796811878084445"], ["X9", "0.00189931547896723"], ["X5", "0.003767628835057246"], ["X7", "0.0039004079659084555"], ["X8", "0.005723060456804183"], ["X4", "0.28175014620383554"], ["X0", "0.3952087499581659"], ["X1", "0.39690151489708575"], ["X3", "0.5963145715059678"]]}], "visualMap": null, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": {"show": true, "custom_tooltip": false, "trigger": "item", "axisPointer": {"show": true}, "showContent": true, "triggerOn": "mousemove|click", "hideDelay": 100, "enterable": true, "renderMode": "html", "confine": true, "transitionDuration": 0.4, "precision": 4, "borderColor": "#333", "padding": 5, "order": "seriesAsc"}, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"width": 600, "height": 600}, "color": ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5006"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };function support_popup(option, height, width, inner_html) {
      option['toolbox']['feature']['myFeature'] = {
        show: true,
        title: 'Open in new window',
        icon: 'image://http://127.0.0.1:5001/resources/popup_icon',
        onclick: function (){
          var height_ = Math.min(screen.height, Math.round(1.5 * parseInt(height.slice(0,-2))))
          var width_ = Math.min(screen.width, Math.round(1.5 * parseInt(width.slice(0,-2))))
          var left = (screen.width/2)-(width_/2);
          var top = (screen.height/2)-(height_/2);
          var win = window.open('template.html', '_blank',
            `height=${height_}px, width=${width_}px, top=${top}px, left=${left}px`,
          );
          win.document.write(`${inner_html}`);
          win.document.close();
        }
      };
      return option;
    };option = support_popup(option=option, height="600px", width="600px", inner_html=`

            <html lang="en" style="height: 100%; text-align: -webkit-center; align-content: center">
            <title>MoCharts</title>
            <head> <meta charset="utf-8"> </head>
            <body style="height: 100%; margin: 0">
        
        
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"><\/script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"><\/script>
            

            <div id="1737119400.1464856" style="height: 90%; width: 90%"></div>
            <script type="text/javascript">
                var dom = document.getElementById('1737119400.1464856');
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
            option = {"chart_id": "1737119400.1464856", "link_id": null, "figname": "", "title": {"show": true, "text": "Feature Selection (Correlation)", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": ["X2", "X6", "X9", "X5", "X7", "X8", "X4", "X0", "X1", "X3"], "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 40.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "type": "value", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "min": -0.2028, "max": 0.8038, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": false, "showMaxLabel": false, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "bar", "colorBy": "series", "z": 2, "legendHoverLink": true, "stack": "", "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "color": "black", "position": null, "fontSize": 12}, "itemStyle": {}, "seriesLayoutBy": "column", "data": [{"value": [0.00027501826451572457, "X2"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.0002796811878084445, "X6"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.00189931547896723, "X9"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.003767628835057246, "X5"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.0039004079659084555, "X7"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.005723060456804183, "X8"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.28175014620383554, "X4"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.3952087499581659, "X0"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.39690151489708575, "X1"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.5963145715059678, "X3"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}], "markLine": {"symbolSize": 0, "silent": true, "label": {"show": false}, "data": [{"xAxis": 0.2, "lineStyle": {"type": "dashed", "color": "red"}}]}, "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "color": "#1f77b4", "coordinateSystem": "cartesian2d", "showBackground": true, "backgroundStyle": {"color": "rgba(180, 180, 180, 0.2)"}, "barWidth": "90%", "barGap": "0", "barCategoryGap": "20%", "largeThreshold": 400, "progressive": 5000, "progressiveThreshold": 3000, "progressiveChunkMode": "mod", "orient": "horizontal", "x_value": ["X2", "X6", "X9", "X5", "X7", "X8", "X4", "X0", "X1", "X3"], "tooltip_type": "axis", "hist": false, "data_value": [["X2", "0.00027501826451572457"], ["X6", "0.0002796811878084445"], ["X9", "0.00189931547896723"], ["X5", "0.003767628835057246"], ["X7", "0.0039004079659084555"], ["X8", "0.005723060456804183"], ["X4", "0.28175014620383554"], ["X0", "0.3952087499581659"], ["X1", "0.39690151489708575"], ["X3", "0.5963145715059678"]]}], "visualMap": null, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": {"show": true, "custom_tooltip": false, "trigger": "item", "axisPointer": {"show": true}, "showContent": true, "triggerOn": "mousemove|click", "hideDelay": 100, "enterable": true, "renderMode": "html", "confine": true, "transitionDuration": 0.4, "precision": 4, "borderColor": "#333", "padding": 5, "order": "seriesAsc"}, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"width": 600, "height": 600}, "color": ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5006"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                myChart.setOption(option);
                window.addEventListener('resize', function () {
                    myChart.resize();
                    var option_copy = JSON.parse(JSON.stringify(option));
                    option_copy['figsize']['height'] = myChart.getHeight();
                    option_copy['figsize']['width'] = myChart.getWidth();
                    // option_copy = auto_component_size(option_copy);
                    myChart.setOption(option_copy);
                });
            <\/script>
            </body>
            </html>
        <style>
    .dg.main.taller-than-window .close-button {
        border-top: 1px solid #ddd;
    }

    .dg.main .close-button {
        background-color: #e8e8e8;
    }
 
    .dg.main .close-button:hover {
        background-color: #ddd;
    }

    .dg {
        color: #555;
        text-shadow: none !important;
    }

    .dg.main::-webkit-scrollbar {
        background: #fafafa;
    }

    .dg.main::-webkit-scrollbar-thumb {
        background: #bbb;
    }
 
    .dg li:not(.folder) {
        background: #fafafa;
        border-bottom: 1px solid #ddd;
    }
 
    .dg li.save-row .button {
        text-shadow: none !important;
    }

    .dg li.title {
        background: #e8e8e8 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
    }

    .dg .cr.function:hover,.dg .cr.boolean:hover {
        background: #fff;
    }
 
    .dg .c input[type=text] {
        background: #e9e9e9;
    }
 
    .dg .c input[type=text]:hover {
        background: #eee;
    }
 
    .dg .c input[type=text]:focus {
        background: #eee;
        color: #555;
    }
 
    .dg .c .slider {
        background: #e9e9e9;
    }

    .dg .c .slider:hover {
        background: #eee;
    }<\/style>`);option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                if (option && typeof option === 'object') {
                    myChart.setOption(option);
                    }

                auto_axis_namegap(echarts_instance=myChart, auto_axis_list=[0], axis_type="2d");

            </script>
            </body>
            </html>
    
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 31-32

XGB-PFI based feature selection

.. GENERATED FROM PYTHON SOURCE LINES 32-35

.. code-block:: Python

    results = ds.feature_select_xgbpfi(threshold=0.01)
    results.plot()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">

                <!DOCTYPE html>
                <html lang="en" style="height: 100%">
                <head>
                <meta charset="utf-8">
                </head>
                <body style="height: 100%; margin: 0">

            
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"></script>
            
                <div id="1737119401.527648" style="height: 600px; width: 600px; overflow: auto"></div>
            
                <script type="text/javascript">
                var dom = document.getElementById('1737119401.527648');
                dom.innerHTML = ""
                dom.setAttribute('_echarts_instance_', '')
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
        option = {"chart_id": "1737119401.527648", "link_id": null, "figname": "", "title": {"show": true, "text": "Feature Selection (XGB-PFI)", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": ["X7", "X9", "X5", "X8", "X6", "X4", "X2", "X1", "X0", "X3"], "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 40.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "type": "value", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "min": -0.1116, "max": 0.4386, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": false, "showMaxLabel": false, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "bar", "colorBy": "series", "z": 2, "legendHoverLink": true, "stack": "", "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "color": "black", "position": null, "fontSize": 12}, "itemStyle": {}, "seriesLayoutBy": "column", "data": [{"value": [2.4777154996433606e-05, "X7"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [2.6460317982821837e-05, "X9"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [2.790246135994419e-05, "X5"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [3.206878080712403e-05, "X8"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [3.55117591562635e-05, "X6"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.0812855989263743, "X4"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.08635079237945374, "X2"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.24820534867660643, "X1"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.2525535209680004, "X0"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.3314580185752627, "X3"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}], "markLine": {"symbolSize": 0, "silent": true, "label": {"show": false}, "data": [{"xAxis": 0.01, "lineStyle": {"type": "dashed", "color": "red"}}]}, "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "color": "#1f77b4", "coordinateSystem": "cartesian2d", "showBackground": true, "backgroundStyle": {"color": "rgba(180, 180, 180, 0.2)"}, "barWidth": "90%", "barGap": "0", "barCategoryGap": "20%", "largeThreshold": 400, "progressive": 5000, "progressiveThreshold": 3000, "progressiveChunkMode": "mod", "orient": "horizontal", "x_value": ["X7", "X9", "X5", "X8", "X6", "X4", "X2", "X1", "X0", "X3"], "tooltip_type": "axis", "hist": false, "data_value": [["X7", "2.4777154996433606e-05"], ["X9", "2.6460317982821837e-05"], ["X5", "2.790246135994419e-05"], ["X8", "3.206878080712403e-05"], ["X6", "3.55117591562635e-05"], ["X4", "0.0812855989263743"], ["X2", "0.08635079237945374"], ["X1", "0.24820534867660643"], ["X0", "0.2525535209680004"], ["X3", "0.3314580185752627"]]}], "visualMap": null, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": {"show": true, "custom_tooltip": false, "trigger": "item", "axisPointer": {"show": true}, "showContent": true, "triggerOn": "mousemove|click", "hideDelay": 100, "enterable": true, "renderMode": "html", "confine": true, "transitionDuration": 0.4, "precision": 4, "borderColor": "#333", "padding": 5, "order": "seriesAsc"}, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"width": 600, "height": 600}, "color": ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5006"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };function support_popup(option, height, width, inner_html) {
      option['toolbox']['feature']['myFeature'] = {
        show: true,
        title: 'Open in new window',
        icon: 'image://http://127.0.0.1:5001/resources/popup_icon',
        onclick: function (){
          var height_ = Math.min(screen.height, Math.round(1.5 * parseInt(height.slice(0,-2))))
          var width_ = Math.min(screen.width, Math.round(1.5 * parseInt(width.slice(0,-2))))
          var left = (screen.width/2)-(width_/2);
          var top = (screen.height/2)-(height_/2);
          var win = window.open('template.html', '_blank',
            `height=${height_}px, width=${width_}px, top=${top}px, left=${left}px`,
          );
          win.document.write(`${inner_html}`);
          win.document.close();
        }
      };
      return option;
    };option = support_popup(option=option, height="600px", width="600px", inner_html=`

            <html lang="en" style="height: 100%; text-align: -webkit-center; align-content: center">
            <title>MoCharts</title>
            <head> <meta charset="utf-8"> </head>
            <body style="height: 100%; margin: 0">
        
        
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"><\/script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"><\/script>
            

            <div id="1737119401.527648" style="height: 90%; width: 90%"></div>
            <script type="text/javascript">
                var dom = document.getElementById('1737119401.527648');
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
            option = {"chart_id": "1737119401.527648", "link_id": null, "figname": "", "title": {"show": true, "text": "Feature Selection (XGB-PFI)", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": ["X7", "X9", "X5", "X8", "X6", "X4", "X2", "X1", "X0", "X3"], "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 40.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "type": "value", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "min": -0.1116, "max": 0.4386, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": false, "showMaxLabel": false, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "bar", "colorBy": "series", "z": 2, "legendHoverLink": true, "stack": "", "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "color": "black", "position": null, "fontSize": 12}, "itemStyle": {}, "seriesLayoutBy": "column", "data": [{"value": [2.4777154996433606e-05, "X7"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [2.6460317982821837e-05, "X9"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [2.790246135994419e-05, "X5"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [3.206878080712403e-05, "X8"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [3.55117591562635e-05, "X6"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.0812855989263743, "X4"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.08635079237945374, "X2"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.24820534867660643, "X1"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.2525535209680004, "X0"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.3314580185752627, "X3"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}], "markLine": {"symbolSize": 0, "silent": true, "label": {"show": false}, "data": [{"xAxis": 0.01, "lineStyle": {"type": "dashed", "color": "red"}}]}, "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "color": "#1f77b4", "coordinateSystem": "cartesian2d", "showBackground": true, "backgroundStyle": {"color": "rgba(180, 180, 180, 0.2)"}, "barWidth": "90%", "barGap": "0", "barCategoryGap": "20%", "largeThreshold": 400, "progressive": 5000, "progressiveThreshold": 3000, "progressiveChunkMode": "mod", "orient": "horizontal", "x_value": ["X7", "X9", "X5", "X8", "X6", "X4", "X2", "X1", "X0", "X3"], "tooltip_type": "axis", "hist": false, "data_value": [["X7", "2.4777154996433606e-05"], ["X9", "2.6460317982821837e-05"], ["X5", "2.790246135994419e-05"], ["X8", "3.206878080712403e-05"], ["X6", "3.55117591562635e-05"], ["X4", "0.0812855989263743"], ["X2", "0.08635079237945374"], ["X1", "0.24820534867660643"], ["X0", "0.2525535209680004"], ["X3", "0.3314580185752627"]]}], "visualMap": null, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": {"show": true, "custom_tooltip": false, "trigger": "item", "axisPointer": {"show": true}, "showContent": true, "triggerOn": "mousemove|click", "hideDelay": 100, "enterable": true, "renderMode": "html", "confine": true, "transitionDuration": 0.4, "precision": 4, "borderColor": "#333", "padding": 5, "order": "seriesAsc"}, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"width": 600, "height": 600}, "color": ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5006"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                myChart.setOption(option);
                window.addEventListener('resize', function () {
                    myChart.resize();
                    var option_copy = JSON.parse(JSON.stringify(option));
                    option_copy['figsize']['height'] = myChart.getHeight();
                    option_copy['figsize']['width'] = myChart.getWidth();
                    // option_copy = auto_component_size(option_copy);
                    myChart.setOption(option_copy);
                });
            <\/script>
            </body>
            </html>
        <style>
    .dg.main.taller-than-window .close-button {
        border-top: 1px solid #ddd;
    }

    .dg.main .close-button {
        background-color: #e8e8e8;
    }
 
    .dg.main .close-button:hover {
        background-color: #ddd;
    }

    .dg {
        color: #555;
        text-shadow: none !important;
    }

    .dg.main::-webkit-scrollbar {
        background: #fafafa;
    }

    .dg.main::-webkit-scrollbar-thumb {
        background: #bbb;
    }
 
    .dg li:not(.folder) {
        background: #fafafa;
        border-bottom: 1px solid #ddd;
    }
 
    .dg li.save-row .button {
        text-shadow: none !important;
    }

    .dg li.title {
        background: #e8e8e8 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
    }

    .dg .cr.function:hover,.dg .cr.boolean:hover {
        background: #fff;
    }
 
    .dg .c input[type=text] {
        background: #e9e9e9;
    }
 
    .dg .c input[type=text]:hover {
        background: #eee;
    }
 
    .dg .c input[type=text]:focus {
        background: #eee;
        color: #555;
    }
 
    .dg .c .slider {
        background: #e9e9e9;
    }

    .dg .c .slider:hover {
        background: #eee;
    }<\/style>`);option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                if (option && typeof option === 'object') {
                    myChart.setOption(option);
                    }

                auto_axis_namegap(echarts_instance=myChart, auto_axis_list=[0], axis_type="2d");

            </script>
            </body>
            </html>
    
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 36-37

RCIT based feature selection

.. GENERATED FROM PYTHON SOURCE LINES 37-40

.. code-block:: Python

    results = ds.feature_select_rcit()
    results.plot()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">

                <!DOCTYPE html>
                <html lang="en" style="height: 100%">
                <head>
                <meta charset="utf-8">
                </head>
                <body style="height: 100%; margin: 0">

            
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"></script>
            
                <div id="1737119405.4322624" style="height: 600px; width: 600px; overflow: auto"></div>
            
                <script type="text/javascript">
                var dom = document.getElementById('1737119405.4322624');
                dom.innerHTML = ""
                dom.setAttribute('_echarts_instance_', '')
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
        option = {"chart_id": "1737119405.4322624", "link_id": null, "figname": "", "title": {"show": true, "text": "Feature Selection (RCIT)", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": ["X0", "X1", "X2", "X3", "X4", "X5", "X6", "X7", "X8", "X9"], "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "inverse": true, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 40.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": "Steps", "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "heatmap", "name": "heatmap", "colorBy": "series", "z": 2, "legendHoverLink": true, "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "fontSize": 12}, "seriesLayoutBy": "column", "data": [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, -1], [0, 4, 0], [0, 5, 1], [0, 6, 1], [0, 7, 1], [0, 8, 1], [0, 9, 1], [1, 0, -1], [1, 1, 0], [1, 2, 0], [1, 3, -1], [1, 4, 0], [1, 5, 1], [1, 6, 1], [1, 7, 1], [1, 8, 1], [1, 9, 1], [2, 0, -1], [2, 1, -1], [2, 2, 0], [2, 3, -1], [2, 4, 0], [2, 5, 1], [2, 6, 1], [2, 7, 1], [2, 8, 1], [2, 9, 1], [3, 0, -1], [3, 1, -1], [3, 2, 0], [3, 3, -1], [3, 4, -1], [3, 5, 1], [3, 6, 1], [3, 7, 1], [3, 8, 1], [3, 9, 1], [4, 0, -1], [4, 1, -1], [4, 2, -1], [4, 3, -1], [4, 4, -1], [4, 5, 1], [4, 6, 1], [4, 7, 1], [4, 8, 1], [4, 9, 1]], "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "coordinateSystem": "cartesian2d", "pointSize": 20, "blurSize": 10, "maxOpacity": 1, "progressive": 400, "progressiveThreshold": 3000, "colsize": 1, "visualmap_type": "continuous", "map_range": [-1, 1]}], "visualMap": {"show": true, "type": "continuous", "color": ["#440154", "#481467", "#482576", "#453781", "#404688", "#39558c", "#33638d", "#2d718e", "#287d8e", "#238a8d", "#1f968b", "#20a386", "#29af7f", "#3dbc74", "#56c667", "#75d054", "#95d840", "#bade28", "#dde318", "#fde725"], "left": "auto", "top": "10%", "right": "1%", "bottom": "auto", "min": -1, "max": 1, "calculable": true, "realtime": true, "precision": 1, "itemWidth": 20, "itemHeight": 140, "align": "auto", "textGap": 10, "hoverLink": true, "z": 4, "padding": 0, "backgroundColor": "rgba(0,0,0,0)", "borderColor": "#ccc", "textStyle": {"fontSize": 12, "width": 35, "overflow": "none", "ellipsis": ".."}, "indicatorSize": "50%", "orient": "vertical", "changed_name_key": {"id_": "id", "type_": "type", "min_": "min", "max_": "max", "range_": "range"}}, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": {"show": true, "custom_tooltip": false, "trigger": "item", "axisPointer": {"show": true}, "showContent": true, "triggerOn": "mousemove|click", "hideDelay": 100, "enterable": true, "renderMode": "html", "confine": true, "transitionDuration": 0.4, "precision": 4, "borderColor": "#333", "padding": 5, "order": "seriesAsc"}, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"width": 600, "height": 600}, "color": ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5006"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };function support_popup(option, height, width, inner_html) {
      option['toolbox']['feature']['myFeature'] = {
        show: true,
        title: 'Open in new window',
        icon: 'image://http://127.0.0.1:5001/resources/popup_icon',
        onclick: function (){
          var height_ = Math.min(screen.height, Math.round(1.5 * parseInt(height.slice(0,-2))))
          var width_ = Math.min(screen.width, Math.round(1.5 * parseInt(width.slice(0,-2))))
          var left = (screen.width/2)-(width_/2);
          var top = (screen.height/2)-(height_/2);
          var win = window.open('template.html', '_blank',
            `height=${height_}px, width=${width_}px, top=${top}px, left=${left}px`,
          );
          win.document.write(`${inner_html}`);
          win.document.close();
        }
      };
      return option;
    };option = support_popup(option=option, height="600px", width="600px", inner_html=`

            <html lang="en" style="height: 100%; text-align: -webkit-center; align-content: center">
            <title>MoCharts</title>
            <head> <meta charset="utf-8"> </head>
            <body style="height: 100%; margin: 0">
        
        
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"><\/script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"><\/script>
            

            <div id="1737119405.4322624" style="height: 90%; width: 90%"></div>
            <script type="text/javascript">
                var dom = document.getElementById('1737119405.4322624');
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
            option = {"chart_id": "1737119405.4322624", "link_id": null, "figname": "", "title": {"show": true, "text": "Feature Selection (RCIT)", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": ["X0", "X1", "X2", "X3", "X4", "X5", "X6", "X7", "X8", "X9"], "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "inverse": true, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 40.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": "Steps", "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "heatmap", "name": "heatmap", "colorBy": "series", "z": 2, "legendHoverLink": true, "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "fontSize": 12}, "seriesLayoutBy": "column", "data": [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, -1], [0, 4, 0], [0, 5, 1], [0, 6, 1], [0, 7, 1], [0, 8, 1], [0, 9, 1], [1, 0, -1], [1, 1, 0], [1, 2, 0], [1, 3, -1], [1, 4, 0], [1, 5, 1], [1, 6, 1], [1, 7, 1], [1, 8, 1], [1, 9, 1], [2, 0, -1], [2, 1, -1], [2, 2, 0], [2, 3, -1], [2, 4, 0], [2, 5, 1], [2, 6, 1], [2, 7, 1], [2, 8, 1], [2, 9, 1], [3, 0, -1], [3, 1, -1], [3, 2, 0], [3, 3, -1], [3, 4, -1], [3, 5, 1], [3, 6, 1], [3, 7, 1], [3, 8, 1], [3, 9, 1], [4, 0, -1], [4, 1, -1], [4, 2, -1], [4, 3, -1], [4, 4, -1], [4, 5, 1], [4, 6, 1], [4, 7, 1], [4, 8, 1], [4, 9, 1]], "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "coordinateSystem": "cartesian2d", "pointSize": 20, "blurSize": 10, "maxOpacity": 1, "progressive": 400, "progressiveThreshold": 3000, "colsize": 1, "visualmap_type": "continuous", "map_range": [-1, 1]}], "visualMap": {"show": true, "type": "continuous", "color": ["#440154", "#481467", "#482576", "#453781", "#404688", "#39558c", "#33638d", "#2d718e", "#287d8e", "#238a8d", "#1f968b", "#20a386", "#29af7f", "#3dbc74", "#56c667", "#75d054", "#95d840", "#bade28", "#dde318", "#fde725"], "left": "auto", "top": "10%", "right": "1%", "bottom": "auto", "min": -1, "max": 1, "calculable": true, "realtime": true, "precision": 1, "itemWidth": 20, "itemHeight": 140, "align": "auto", "textGap": 10, "hoverLink": true, "z": 4, "padding": 0, "backgroundColor": "rgba(0,0,0,0)", "borderColor": "#ccc", "textStyle": {"fontSize": 12, "width": 35, "overflow": "none", "ellipsis": ".."}, "indicatorSize": "50%", "orient": "vertical", "changed_name_key": {"id_": "id", "type_": "type", "min_": "min", "max_": "max", "range_": "range"}}, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": {"show": true, "custom_tooltip": false, "trigger": "item", "axisPointer": {"show": true}, "showContent": true, "triggerOn": "mousemove|click", "hideDelay": 100, "enterable": true, "renderMode": "html", "confine": true, "transitionDuration": 0.4, "precision": 4, "borderColor": "#333", "padding": 5, "order": "seriesAsc"}, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"width": 600, "height": 600}, "color": ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5006"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                myChart.setOption(option);
                window.addEventListener('resize', function () {
                    myChart.resize();
                    var option_copy = JSON.parse(JSON.stringify(option));
                    option_copy['figsize']['height'] = myChart.getHeight();
                    option_copy['figsize']['width'] = myChart.getWidth();
                    // option_copy = auto_component_size(option_copy);
                    myChart.setOption(option_copy);
                });
            <\/script>
            </body>
            </html>
        <style>
    .dg.main.taller-than-window .close-button {
        border-top: 1px solid #ddd;
    }

    .dg.main .close-button {
        background-color: #e8e8e8;
    }
 
    .dg.main .close-button:hover {
        background-color: #ddd;
    }

    .dg {
        color: #555;
        text-shadow: none !important;
    }

    .dg.main::-webkit-scrollbar {
        background: #fafafa;
    }

    .dg.main::-webkit-scrollbar-thumb {
        background: #bbb;
    }
 
    .dg li:not(.folder) {
        background: #fafafa;
        border-bottom: 1px solid #ddd;
    }
 
    .dg li.save-row .button {
        text-shadow: none !important;
    }

    .dg li.title {
        background: #e8e8e8 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
    }

    .dg .cr.function:hover,.dg .cr.boolean:hover {
        background: #fff;
    }
 
    .dg .c input[type=text] {
        background: #e9e9e9;
    }
 
    .dg .c input[type=text]:hover {
        background: #eee;
    }
 
    .dg .c input[type=text]:focus {
        background: #eee;
        color: #555;
    }
 
    .dg .c .slider {
        background: #e9e9e9;
    }

    .dg .c .slider:hover {
        background: #eee;
    }<\/style>`);option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                if (option && typeof option === 'object') {
                    myChart.setOption(option);
                    }

                auto_axis_namegap(echarts_instance=myChart, auto_axis_list=[0], axis_type="2d");

            </script>
            </body>
            </html>
    
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 41-42

Apply feature selection

.. GENERATED FROM PYTHON SOURCE LINES 42-45

.. code-block:: Python

    ds.set_active_features(features=results.value["selected"])
    ds.feature_names





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ['X0', 'X1', 'X2', 'X3', 'X4']



.. GENERATED FROM PYTHON SOURCE LINES 46-47

Conduct another round of feature selection

.. GENERATED FROM PYTHON SOURCE LINES 47-50

.. code-block:: Python

    results = ds.feature_select_xgbpfi(threshold=0.1)
    results.plot()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">

                <!DOCTYPE html>
                <html lang="en" style="height: 100%">
                <head>
                <meta charset="utf-8">
                </head>
                <body style="height: 100%; margin: 0">

            
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"></script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"></script>
            
                <div id="1737119406.2400284" style="height: 600px; width: 600px; overflow: auto"></div>
            
                <script type="text/javascript">
                var dom = document.getElementById('1737119406.2400284');
                dom.innerHTML = ""
                dom.setAttribute('_echarts_instance_', '')
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
        option = {"chart_id": "1737119406.2400284", "link_id": null, "figname": "", "title": {"show": true, "text": "Feature Selection (XGB-PFI)", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": ["X4", "X2", "X1", "X0", "X3"], "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 40.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "type": "value", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "min": -0.0048, "max": 0.4208, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": false, "showMaxLabel": false, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "bar", "colorBy": "series", "z": 2, "legendHoverLink": true, "stack": "", "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "color": "black", "position": null, "fontSize": 12}, "itemStyle": {}, "seriesLayoutBy": "column", "data": [{"value": [0.08132746101865324, "X4"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.08628603299709124, "X2"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.24836285021065274, "X1"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.2529762117485528, "X0"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.33104744402504993, "X3"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}], "markLine": {"symbolSize": 0, "silent": true, "label": {"show": false}, "data": [{"xAxis": 0.1, "lineStyle": {"type": "dashed", "color": "red"}}]}, "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "color": "#1f77b4", "coordinateSystem": "cartesian2d", "showBackground": true, "backgroundStyle": {"color": "rgba(180, 180, 180, 0.2)"}, "barWidth": "90%", "barGap": "0", "barCategoryGap": "20%", "largeThreshold": 400, "progressive": 5000, "progressiveThreshold": 3000, "progressiveChunkMode": "mod", "orient": "horizontal", "x_value": ["X4", "X2", "X1", "X0", "X3"], "tooltip_type": "axis", "hist": false, "data_value": [["X4", "0.08132746101865324"], ["X2", "0.08628603299709124"], ["X1", "0.24836285021065274"], ["X0", "0.2529762117485528"], ["X3", "0.33104744402504993"]]}], "visualMap": null, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": {"show": true, "custom_tooltip": false, "trigger": "item", "axisPointer": {"show": true}, "showContent": true, "triggerOn": "mousemove|click", "hideDelay": 100, "enterable": true, "renderMode": "html", "confine": true, "transitionDuration": 0.4, "precision": 4, "borderColor": "#333", "padding": 5, "order": "seriesAsc"}, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"width": 600, "height": 600}, "color": ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5006"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };function support_popup(option, height, width, inner_html) {
      option['toolbox']['feature']['myFeature'] = {
        show: true,
        title: 'Open in new window',
        icon: 'image://http://127.0.0.1:5001/resources/popup_icon',
        onclick: function (){
          var height_ = Math.min(screen.height, Math.round(1.5 * parseInt(height.slice(0,-2))))
          var width_ = Math.min(screen.width, Math.round(1.5 * parseInt(width.slice(0,-2))))
          var left = (screen.width/2)-(width_/2);
          var top = (screen.height/2)-(height_/2);
          var win = window.open('template.html', '_blank',
            `height=${height_}px, width=${width_}px, top=${top}px, left=${left}px`,
          );
          win.document.write(`${inner_html}`);
          win.document.close();
        }
      };
      return option;
    };option = support_popup(option=option, height="600px", width="600px", inner_html=`

            <html lang="en" style="height: 100%; text-align: -webkit-center; align-content: center">
            <title>MoCharts</title>
            <head> <meta charset="utf-8"> </head>
            <body style="height: 100%; margin: 0">
        
        
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/echarts-gl/2.0.8/echarts-gl.min.js"><\/script>
                <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"><\/script>
                <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"><\/script>
            

            <div id="1737119406.2400284" style="height: 90%; width: 90%"></div>
            <script type="text/javascript">
                var dom = document.getElementById('1737119406.2400284');
                var myChart = echarts.init(dom, null, {
                    renderer: 'canvas',
                    useDirtyRect: false
                    });
                var app = {};

                var option;
            option = {"chart_id": "1737119406.2400284", "link_id": null, "figname": "", "title": {"show": true, "text": "Feature Selection (XGB-PFI)", "link": "", "target": "blank", "textStyle": {"fontStyle": "normal", "fontWeight": "bolder", "fontFamily": "sans-serif", "fontSize": 15, "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "subtext": "", "sublink": "", "subtarget": "blank", "textAlign": "center", "textVerticalAlign": "auto", "padding": 0, "itemGap": 10, "z": 2, "left": "50.0%", "top": "5%", "right": "auto", "bottom": "auto", "backgroundColor": "transparent", "borderColor": "#ccc", "changed_name_key": {"id_": "id"}}, "grid": {"show": true, "width": "auto", "height": "auto", "z": 2, "left": "5%", "top": "10%", "right": "10%", "bottom": "5%", "borderColor": "#ccc", "borderWidth": 1, "containLabel": true, "backgroundColor": "transparent", "changed_name_key": {"id_": "id"}}, "legend": null, "brush": null, "yAxis": [{"show": true, "data": ["X4", "X2", "X1", "X0", "X3"], "type": "category", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": "auto", "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": true, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": 40.0}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "xAxis": [{"show": true, "type": "value", "position": "bottom", "name": "", "nameLocation": "center", "nameTextStyle": {"color": "black", "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "..."}, "nameGap": 30, "min": -0.0048, "max": 0.4208, "splitNumber": 5, "logBase": 10, "axisLine": {}, "axisTick": {"show": true, "alignWithLabel": "none", "interval": "auto", "length": 5}, "axisLabel": {"show": true, "margin": 8, "showMinLabel": false, "showMaxLabel": false, "fontStyle": "normal", "fontWeight": "normal", "fontFamily": "sans-serif", "fontSize": 12, "backgroundColor": "transparent", "borderType": "solid", "shadowColor": "transparent", "textBorderType": "solid", "textShadowColor": "transparent", "overflow": "none", "ellipsis": "...", "width": null}, "splitLine": {"show": true, "interval": "auto"}, "splitArea": {"show": false, "interval": "auto"}, "axisPointer": {"show": false}, "dimension": "2d", "ignored": false, "changed_name_key": {"min_": "min", "max_": "max", "type_": "type", "name_": "name"}}], "parallelAxis": null, "series": [{"type": "bar", "colorBy": "series", "z": 2, "legendHoverLink": true, "stack": "", "stackStrategy": "samesign", "cursor": "pointer", "clip": true, "label": {"show": false, "color": "black", "position": null, "fontSize": 12}, "itemStyle": {}, "seriesLayoutBy": "column", "data": [{"value": [0.08132746101865324, "X4"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.08628603299709124, "X2"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.24836285021065274, "X1"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.2529762117485528, "X0"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}, {"value": [0.33104744402504993, "X3"], "itemStyle": {"color": "#1f77b4"}, "visualMap": false}], "markLine": {"symbolSize": 0, "silent": true, "label": {"show": false}, "data": [{"xAxis": 0.1, "lineStyle": {"type": "dashed", "color": "red"}}]}, "animation": true, "animationThreshold": 2000, "animationDuration": 1000, "animationEasing": "cubicOut", "animationDurationUpdate": 300, "animationEasingUpdate": "cubicOut", "color": "#1f77b4", "coordinateSystem": "cartesian2d", "showBackground": true, "backgroundStyle": {"color": "rgba(180, 180, 180, 0.2)"}, "barWidth": "90%", "barGap": "0", "barCategoryGap": "20%", "largeThreshold": 400, "progressive": 5000, "progressiveThreshold": 3000, "progressiveChunkMode": "mod", "orient": "horizontal", "x_value": ["X4", "X2", "X1", "X0", "X3"], "tooltip_type": "axis", "hist": false, "data_value": [["X4", "0.08132746101865324"], ["X2", "0.08628603299709124"], ["X1", "0.24836285021065274"], ["X0", "0.2529762117485528"], ["X3", "0.33104744402504993"]]}], "visualMap": null, "toolbox": {"show": true, "orient": "horizontal", "itemSize": 15, "itemGap": 8, "showTitle": true, "feature": {"dataZoom": {}, "saveAsImage": {}}, "z": 2, "left": "auto", "top": "auto", "right": "1%", "bottom": "auto", "width": "auto", "height": "auto", "popup": true, "changed_name_key": {"id_": "id"}}, "tooltip": {"show": true, "custom_tooltip": false, "trigger": "item", "axisPointer": {"show": true}, "showContent": true, "triggerOn": "mousemove|click", "hideDelay": 100, "enterable": true, "renderMode": "html", "confine": true, "transitionDuration": 0.4, "precision": 4, "borderColor": "#333", "padding": 5, "order": "seriesAsc"}, "dataZoom": null, "event": null, "graphic": null, "radar": null, "figsize": {"width": 600, "height": 600}, "color": ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"], "save_img": false, "auto_size": true, "style": {"overflow": "auto"}, "port": "5006"};function setInnerHTML(elm, html) {
      elm.innerHTML = html;
  
      Array.from(elm.querySelectorAll("script"))
        .forEach( oldScriptEl => {
          const newScriptEl = document.createElement("script");
      
          Array.from(oldScriptEl.attributes).forEach( attr => {
            newScriptEl.setAttribute(attr.name, attr.value) 
          });
      
          const scriptText = document.createTextNode(oldScriptEl.innerHTML);
          newScriptEl.appendChild(scriptText);
      
          oldScriptEl.parentNode.replaceChild(newScriptEl, oldScriptEl);
      });
    };

    function getScreenSize(option) {
      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_result_save', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'height': screen.height, 'width': screen.width},
                                  'event_id': 'screen_size'})
          });
          fetch(testRequest).then(response => {});
      return 
    }
    function support_scientific_notation(option) {
      if (Array.isArray(option['yAxis'])) {
        for (var tar_ind = 0; tar_ind < option['yAxis'].length; tar_ind++) {
          if (option['yAxis'][tar_ind]['type'] === 'value') {
            option['yAxis'][tar_ind]['axisLabel']['formatter'] = function(val) {
              const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                        '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                        '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
              function toSuperscript(val) {
                if (val.toString().length > 5 && !val.toString().includes('.')) {
                  val = Number(val).toExponential().toString();
                  if (val.includes('-')) {
                    val = val.split('-');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁻' + val1
                  }
                  else if (val.includes('+')) {
                    val = val.split('+');
                    var val0 = val[0];
                    var val1 = superscripts[val[1]];
                    return val0 + '⁺' + val1
                  }
                }
                else {
                  return val
                }
              }
              return toSuperscript(val)
            }
          }
        }
      }
      else {
        if (option['yAxis']['type'] === 'value') {
          option['yAxis']['axisLabel']['formatter'] = function(val) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹','¹⁰',
                    '¹¹', '¹²', '¹³', '¹⁴', '¹⁵', '¹⁶', '¹⁷', '¹⁸', '¹⁹','²⁰',
                    '²¹', '²²', '²³', '²⁴', '²⁵', '²⁶', '²⁷', '²⁸', '²⁹'];
            function toSuperscript(val) {
              if (val.toString().length > 5 && !val.toString().includes('.')) {
                val = Number(val).toExponential().toString();
                if (val.includes('-')) {
                  val = val.split('-');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁻' + val1
                }
                else if (val.includes('+')) {
                  val = val.split('+');
                  var val0 = val[0];
                  var val1 = superscripts[val[1]];
                  return val0 + '⁺' + val1
                }
              }
              else {
                return val
              }
            }
            return toSuperscript(val)
          }
        }
      };
      return option;
    };

    function auto_component_size(option) {
      if (typeof option['figsize']['width'] === 'string' || option['figsize']['width'] instanceof String) {
        if (option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['width'].includes('px')) {
          var width = parseFloat(option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = option['figsize']['width']
      }

      if (typeof option['figsize']['height'] === 'string' || option['figsize']['height'] instanceof String) {
        if (option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (option['figsize']['height'].includes('px')) {
          var height = parseFloat(option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height']
      }

      var relative_ratio = Math.min(width / 700, height / 400)
      if ('xAxis3D' in option) {
        var keys = ['xAxis3D', 'yAxis3D', 'zAxis3D']
      }
      else {
        var keys = ['xAxis', 'yAxis']
      }
      for (single_key of keys) {
        for (var ind = 0; ind < option[single_key].length; ind++) {
          option[single_key][ind]['nameTextStyle']['fontSize'] = Math.max(7, option[single_key][ind]['nameTextStyle']['fontSize'] * relative_ratio);
          option[single_key][ind]['axisLabel']['fontSize'] = Math.max(7, option[single_key][ind]['axisLabel']['fontSize'] * relative_ratio);
        }
      }
      if (option['series']) {
        for (var ind = 0; ind < option['series'].length; ind++) {
          if (['heatmap', 'bar'].includes(option['series'][ind]['type'])) {
            if (option['series'][ind]['label']) {
              option['series'][ind]['label']['fontSize'] = Math.max(7, option['series'][ind]['label']['fontSize'] * relative_ratio);
            }
          }
        }
      }
      if (option['title']) {
        if (Array.isArray(option['title'])) {
          for (var ind = 0; ind < option['title'].length; ind++) {
            option['title'][ind]['textStyle']['fontSize'] = Math.max(9, option['title'][ind]['textStyle']['fontSize'] * relative_ratio);
          }
        }
        else {
          option['title']['textStyle']['fontSize'] = Math.max(9, option['title']['textStyle']['fontSize'] * relative_ratio);
        }
      }
      if (option['legend']) {
        option['legend']['itemHeight'] = option['legend']['itemHeight'] * relative_ratio;
        option['legend']['itemWidth'] = option['legend']['itemWidth'] * relative_ratio;
        option['legend']['textStyle']['fontSize'] = Math.max(7, option['legend']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['visualMap']) {
        option['visualMap']['itemHeight'] = option['visualMap']['itemHeight'] * relative_ratio;
        option['visualMap']['itemWidth'] = option['visualMap']['itemWidth'] * relative_ratio;
        option['visualMap']['textStyle']['fontSize'] = Math.max(7, option['visualMap']['textStyle']['fontSize'] * relative_ratio);
      }
      if (option['toolbox']) {
        option['toolbox']['itemSize'] = Math.max(8, option['toolbox']['itemSize'] * relative_ratio)
        option['toolbox']['itemGap'] = Math.max(4, option['toolbox']['itemGap'] * relative_ratio);
      }
      if (option['graphic']) {
        for (var ind = 0; ind < option['graphic'].length; ind++) {
          for (var ind2 = 0; ind2 < option['graphic'][ind]['children'].length; ind2++) {
            var new_font = Math.max(7, 12 * relative_ratio);
            option['graphic'][ind]['children'][ind2]['style']['font'] = new_font.toString() + 'px Microsoft YaHei';
          }
        }
      }
      return option;
    }

    function save_img(echarts_instance, option) {
      const base64_str = echarts_instance.getDataURL({
          pixelRatio: 2,
          backgroundColor: '#fff',
          width: option['figsize']['width'],
          height: option['figsize']['height']
      });

      let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_image_save', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json;charset=utf-8;',
          'Access-Control-Allow-Origin':'*',
          'Access-Control-Allow-Credentials': 'true',
          'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
        },
        body: JSON.stringify({'figname': option['figname'],
                              'base64_str': base64_str})
      });
      fetch(testRequest).then(response => {});
    };


    function auto_axis_namegap(echarts_instance, auto_axis_list, axis_type) {
      const globalModel = echarts_instance._api.getModel()
      const figsize = globalModel.option.figsize
      const ctx = document.createElement('canvas').getContext('2d')
      if (typeof globalModel.option['figsize']['width'] === 'string' || globalModel.option['figsize']['width'] instanceof String) {
        if (globalModel.option['figsize']['width'].includes('%')) {
          var width = 800 * (parseFloat(globalModel.option['figsize']['width'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['width'].includes('px')) {
          var width = parseFloat(globalModel.option['figsize']['width'].slice(0,-2));
        }
      }
      else {
        var width = globalModel.option['figsize']['width'];
      }

      if (typeof globalModel.option['figsize']['height'] === 'string' || globalModel.option['figsize']['height'] instanceof String) {
        if (globalModel.option['figsize']['height'].includes('%')) {
          var height = 600 * (parseFloat(globalModel.option['figsize']['height'].slice(0,-1)) / 100);
        }
        else if (globalModel.option['figsize']['height'].includes('px')) {
          var height = parseFloat(globalModel.option['figsize']['height'].slice(0,-2));
        }
      }
      else {
        var height = option['figsize']['height'];
      }
      var relative_ratio = Math.min(width / 700, height / 400);
      if (axis_type==='2d') {
        const yAxisList = globalModel.option.yAxis
        const xAxisList = globalModel.option.xAxis

        for (var axis_idx of auto_axis_list) {
          const yAxis = yAxisList[axis_idx]
          const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
          const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
          ctx.save()
          ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
  
          const yAxisComponent = globalModel.getComponent('yAxis', axis_idx)?.axis
          if (yAxis.type === 'value') {
            var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
          }
          else {
            var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
          }
          var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
          axisLabelMargin = axisLabelMargin * relative_ratio
          yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
          ctx.restore()
        };
  
        for (var axis_idx of [...Array(xAxisList.length).keys()]) {
          var new_gap = Math.max(xAxisList[axis_idx].nameGap * relative_ratio, 12);
          if (figsize['height'] < 400) {
            new_gap = Math.min(20, new_gap);
          }
          xAxisList[axis_idx].nameGap = new_gap;
        }
  
        echarts_instance.setOption({
          yAxis: yAxisList,
          xAxis: xAxisList
        })
      }
      else {
        const yAxisList = globalModel.option.yAxis3D
        const xAxisList = globalModel.option.xAxis3D
        const zAxisList = globalModel.option.zAxis3D

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < xAxisList.length) {
            const xAxis = xAxisList[axis_idx]
            const fontSize = xAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = xAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const xAxisComponent = globalModel.getComponent('xAxis3D', axis_idx)?.axis
            if (xAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...xAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = xAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            xAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < yAxisList.length) {
            const yAxis = yAxisList[axis_idx]
            const fontSize = yAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = yAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const yAxisComponent = globalModel.getComponent('yAxis3D', axis_idx)?.axis
            if (yAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...yAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = yAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            yAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };

        for (var axis_idx of auto_axis_list) {
          if (axis_idx < zAxisList.length) {
            const zAxis = zAxisList[axis_idx]
            const fontSize = zAxis.nameTextStyle?.fontSize ?? 12
            const fontFamily = zAxis.nameTextStyle?.fontFamily ?? 'sans-serif'
            ctx.save()
            ctx.font = fontSize.toString() + 'px' + fontFamily.toString()
    
            const zAxisComponent = globalModel.getComponent('zAxis3D', axis_idx)?.axis
            if (zAxis.type === 'value') {
              var labelMaxWidth = Math.min(Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width)), 30)
            }
            else {
              var labelMaxWidth = Math.max(...zAxisComponent.getViewLabels().map(item => ctx.measureText(item.formattedLabel).width))
            }
            var axisLabelMargin = zAxis.axisLabel?.margin ?? 8
            axisLabelMargin = axisLabelMargin * relative_ratio
            zAxisList[axis_idx].nameGap = labelMaxWidth + axisLabelMargin + 5 * relative_ratio
            ctx.restore()
          }
        };
        echarts_instance.setOption({
          yAxis3D: yAxisList,
          xAxis3D: xAxisList,
          zAxis3D: zAxisList
        });
        }
  
    };

    function custom_scatter_size(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['symbolSize'] === 'array_size') {
          var ind_ = option['series'][ind]['data_dict']['size']
          option['series'][ind]['symbolSize'] = function (data) {return data[ind_];}
        }
      }
      return option;
  
    };

    function show_scatter_label(option) {
  
      for (var ind = 0; ind < option['series'].length; ind++) {
        if (option['series'][ind]['label'] === 'show_label') {
          var ind_ = option['series'][ind]['data_dict']['label']
          option['series'][ind]['label'] = {
            show: true,
            formatter: function (params) {return params.data.value[ind_]; }
          }
        }
      }
      return option;
    };

    function hide_min_max_axis_label(option) {
      for (var ind = 0; ind < option['xAxis3D'].length; ind++) {
        if (option['xAxis3D'][ind]['type'] == 'value') {
          var x_min = option['xAxis3D'][ind]['min']
          var x_max = option['xAxis3D'][ind]['max']
          option['xAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==x_min || value==x_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['yAxis3D'].length; ind++) {
        if (option['yAxis3D'][ind]['type'] == 'value') {  
          var y_min = option['yAxis3D'][ind]['min']
          var y_max = option['yAxis3D'][ind]['max']
          option['yAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==y_min || value==y_max){}
            else {return value}
          }
        }
      }
      for (var ind = 0; ind < option['zAxis3D'].length; ind++) {
        if (option['zAxis3D'][ind]['type'] == 'value') {
          var z_min = option['zAxis3D'][ind]['min']
          var z_max = option['zAxis3D'][ind]['max']
          option['zAxis3D'][ind]['axisLabel']['formatter'] = function (value, index) {
            if (value==z_min || value==z_max){}
            else {return value}
          }
       }
      }
      return option;
    }

    function custom_axis_label(option) {
      if (Array.isArray(option['xAxis'])) {
        for (var ind = 0; ind < option['xAxis'].length; ind++) {
          if (option['xAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['xAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['xAxis'][ind]['axisLabel']['formatter_func'].body)
            option['xAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['xAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['xAxis']['axisLabel']['formatter_func'].arguments,
                               option['xAxis']['axisLabel']['formatter_func'].body)
          option['xAxis']['axisLabel']['formatter'] = f
        }
      }
      if (Array.isArray(option['yAxis'])) {
        for (var ind = 0; ind < option['yAxis'].length; ind++) {
          if (option['yAxis'][ind]['axisLabel']['formatter_func']) {
            var f = new Function(option['yAxis'][ind]['axisLabel']['formatter_func'].arguments,
                                 option['yAxis'][ind]['axisLabel']['formatter_func'].body)
            option['yAxis'][ind]['axisLabel']['formatter'] = f
          }
        }
      }
      else {
        if (option['yAxis']['axisLabel']['formatter_func']) {
          var f = new Function(option['yAxis']['axisLabel']['formatter_func'].arguments,
                               option['yAxis']['axisLabel']['formatter_func'].body)
          option['yAxis']['axisLabel']['formatter'] = f
        }
      }
      return option;
    }

    function custom_tooltip(option, dimension=2) {

      if (dimension === 2) {
        var xaxis_key = 'xAxis'
        var yaxis_key = 'yAxis'
      }

      else if (dimension === 3) {
        var xaxis_key = 'xAxis3D'
        var yaxis_key = 'yAxis3D'
        var zaxis_key = 'zAxis3D'
      }

      if (option['radar']) {
        var radar_names = []
        for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
          radar_names.push(option['radar']['indicator'][ind_]['name']) 
        }
      }
  
  
      if (option[xaxis_key]['name'] !== null && option[xaxis_key]['name'] !== '' && Array.isArray(option[xaxis_key])!==true) {
        var xaxis_name = option[xaxis_key]['name'];
      }
      else {
        var xaxis_name = 'X';
      }

      if (option[yaxis_key]['name'] !== null && option[yaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
        var yaxis_name = option[yaxis_key]['name'];
      }
      else {
        var yaxis_name = 'Y';
      }

      if (typeof zaxis_key !== 'undefined') {
        if (option[zaxis_key]['name'] !== ''&& Array.isArray(option[xaxis_key])!==true) {
          var zaxis_name = option[zaxis_key]['name'];
        }
        else {
          var zaxis_name = 'Z';
        }
      }
  
      if (option['tooltip']) {
        if (option['tooltip']['precision']) {
          var precision = option['tooltip']['precision']
          option['tooltip']['valueFormatter'] = (value) =>  Math.round(Number(value) * (10**precision)) / (10**precision)
        }

        for (var ind_ = 0; ind_ < option['series'].length; ind_++) {
          if (option['series'][ind_]['tooltip']) {
            if (option['series'][ind_]['tooltip']['precision']) {
              var precision = option['series'][ind_]['tooltip']['precision']
              const fix = precision_ => value => Math.round(Number(value) * (10**precision_)) / (10**precision_),
              fix_p = fix(precision);
              option['series'][ind_]['tooltip']['valueFormatter'] = function (value) {
                return fix_p(value)
              } 
            }
          }
        }

        if (option['series'].length === 1) {
          if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][0]['type'])) {
            option['tooltip']['formatter'] = function(params) {
              if (params.seriesName.includes('series')) {
                var series_name = ''
              }
          
              else {
                var series_name = params.seriesName + '<br>'
              }
      
              if (params.seriesType === 'scatter') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                  + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                  +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                }
            
              }
  
              else if (params.seriesType === 'heatmap') {
                formatter = params.name + ', ' + option['yAxis'][0]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
              }
      
              else if (params.seriesType === 'scatter3D') {
                if (option['tooltip']['custom_tooltip'] === true) {
                  formatter = series_name
                    + params.value[dimension]
                }
                else {
                  formatter = series_name
                    + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                    +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                    +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                }
              }
          
              else if (params.seriesType === 'radar') {
                formatter = params.name  + '<br>';
                for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                  if (ind_ !== option['radar']['indicator'].length - 1) {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                  }
                  else {
                    formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                  }
                }
              }
            return formatter;
            }
          }
        }
        else {
          for (var out_ind_ = 0; out_ind_ < option['series'].length; out_ind_++) {
            if (['scatter', 'heatmap', 'scatter3D', 'radar'].includes(option['series'][out_ind_]['type'])) {
              if (option['series'][out_ind_]['tooltip']) {
              }
              else {
                option['series'][out_ind_]['tooltip'] = {}
              }
              option['series'][out_ind_]['tooltip']['formatter'] = function(params) {
                if (params.seriesName.includes('series')) {
                  var series_name = ''
                }
            
                else {
                  var series_name = params.seriesName + '<br>'
                }
        
                if (params.seriesType === 'scatter') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                  }
                }
    
                else if (params.seriesType === 'heatmap') {
                  if ('data' in option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]) {
                    formatter = params.name + ', ' + option['yAxis'][option['series'][params.seriesIndex]['yAxisIndex']]['data'][params.data[1]] + '<br> <b>' + Math.round(params.data[2] * 10000) / 10000
                  }
                  else {
                    formatter = Math.round(params.data[2] * 10000) / 10000
                  }
                
                }
        
                else if (params.seriesType === 'scatter3D') {
                  if (option['tooltip']['custom_tooltip'] === true) {
                    formatter = series_name
                      + params.value[dimension]
                  }
                  else {
                    formatter = series_name
                      + xaxis_name + ': '+ Math.round(params.value[0] * 100) / 100
                      +'<br>' + yaxis_name + ': ' + Math.round(params.value[1] * 100) / 100
                      +'<br>' + zaxis_name + ': ' + Math.round(params.value[2] * 100) / 100
                  }
                }
            
                else if (params.seriesType === 'radar') {
                  formatter = params.name  + '<br>';
                  for (var ind_ = 0; ind_ < option['radar']['indicator'].length; ind_++) {
                    if (ind_ !== option['radar']['indicator'].length - 1) {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100 + '<br>'
                    }
                    else {
                      formatter += radar_names[ind_] + ': ' + Math.round(params.value[ind_] * 100) / 100
                    }
                  }
                }
              return formatter;
              }
            }
          }
        }
      }
      return option;
    };

    function support_brush_event(option) {
      if (option['event']['type_'] === 'brushselected') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });
        var last_selected = [];
        bind_chart.on(option['event']['type_'], (params) => {
          var brushed = [];
          var brushComponent = params.batch[0];
          for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
            var rawIndices = brushComponent.selected[sIdx].dataIndex;
            brushed.push(rawIndices);
          }
          var brushed_all = brushed[0];

          if (JSON.stringify(last_selected) !== JSON.stringify(brushed_all)) {

            // Update memory
            let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
              method: 'post',
              headers: {
                  'Content-Type': 'application/json;charset=utf-8;',
                  'Access-Control-Allow-Origin':'*',
                  'Access-Control-Allow-Credentials': 'true',
                  'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
              },
              body: JSON.stringify({'js_func_input':{'selected': brushed_all},
                                    'event_id': option['event']['event_id']})
            });
            var dom_dict = {}
            fetch(testRequest).then(response => {
              var result = response.json();
              result.then(res => {
                dom_dict[res['link_id']] = document.getElementById(res['link_id']);
                setInnerHTML(dom_dict[res['link_id']], res['html']);
              });
            });
            last_selected = brushed_all;
          }
                            
        // bind_chart.setOption(option);
        })
      }
      return option;
    };

    function support_click_event(option) {
      if (option['event']['type_'] === 'click') {
        if (option['link_id'] === null) {
          var link_id = option['chart_id'];
        }
        else {
          var link_id = option['link_id'];
        }
        var dom = document.getElementById(link_id);
        var bind_chart = echarts.init(dom, null, {
            renderer: 'canvas',
            useDirtyRect: false
        });

        if (option['series'][0]['orient'] === 'vertical') {
          var value_idx = 0
        }
        else {
          var value_idx = 1
        }
    

        bind_chart.on(option['event']['type_'], (params) => {
          if (option['event']['task'] === 'singleselect') {
            for (var ind_2 = 0; ind_2 < option['series'][0]['data'].length; ind_2++) {
              if (option['series'][0]['data'][ind_2]['itemStyle']['color'] !== '#1f77b4') {
                option['series'][0]['data'][ind_2]['itemStyle']['color'] = '#1f77b4';
              }
            }
            var idx = option['series'][0]['x_value'].indexOf(params.value[value_idx])
            option['series'][0]['data'][idx]['itemStyle']['color'] = '#ff7f0e';

            var selected = params.value[value_idx];
          }
          else {
            console.log(params);
          }
      
          let testRequest = new Request('http://localhost:' + option['port'] +'/function/js_call_python_function', {
            method: 'post',
            headers: {
              'Content-Type': 'application/json;charset=utf-8;',
              'Access-Control-Allow-Origin':'*',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods':'POST,PATCH,OPTIONS'
            },
            body: JSON.stringify({'js_func_input':{'selected': selected},
                                  'event_id': option['event']['event_id']})
          });
          var dom_dict = {}
          fetch(testRequest).then(response => {
            var result = response.json();
            result.then(res => {
              dom_dict[res['link_id']] = document.getElementById(res['link_id']);
              setInnerHTML(dom_dict[res['link_id']], res['html']);
            });
          });
          bind_chart.setOption(option);
        });
      }
      return option;
    };option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                myChart.setOption(option);
                window.addEventListener('resize', function () {
                    myChart.resize();
                    var option_copy = JSON.parse(JSON.stringify(option));
                    option_copy['figsize']['height'] = myChart.getHeight();
                    option_copy['figsize']['width'] = myChart.getWidth();
                    // option_copy = auto_component_size(option_copy);
                    myChart.setOption(option_copy);
                });
            <\/script>
            </body>
            </html>
        <style>
    .dg.main.taller-than-window .close-button {
        border-top: 1px solid #ddd;
    }

    .dg.main .close-button {
        background-color: #e8e8e8;
    }
 
    .dg.main .close-button:hover {
        background-color: #ddd;
    }

    .dg {
        color: #555;
        text-shadow: none !important;
    }

    .dg.main::-webkit-scrollbar {
        background: #fafafa;
    }

    .dg.main::-webkit-scrollbar-thumb {
        background: #bbb;
    }
 
    .dg li:not(.folder) {
        background: #fafafa;
        border-bottom: 1px solid #ddd;
    }
 
    .dg li.save-row .button {
        text-shadow: none !important;
    }

    .dg li.title {
        background: #e8e8e8 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
    }

    .dg .cr.function:hover,.dg .cr.boolean:hover {
        background: #fff;
    }
 
    .dg .c input[type=text] {
        background: #e9e9e9;
    }
 
    .dg .c input[type=text]:hover {
        background: #eee;
    }
 
    .dg .c input[type=text]:focus {
        background: #eee;
        color: #555;
    }
 
    .dg .c .slider {
        background: #e9e9e9;
    }

    .dg .c .slider:hover {
        background: #eee;
    }<\/style>`);option = support_scientific_notation(option=option);option = custom_tooltip(option=option, dimension=2);option = custom_axis_label(option=option);option = auto_component_size(option=option);getScreenSize(option=option);

                if (option && typeof option === 'object') {
                    myChart.setOption(option);
                    }

                auto_axis_namegap(echarts_instance=myChart, auto_axis_list=[0], axis_type="2d");

            </script>
            </body>
            </html>
    
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 51-52

Apply another round of feature selection

.. GENERATED FROM PYTHON SOURCE LINES 52-55

.. code-block:: Python

    ds.set_active_features(features=results.value["selected"])
    ds.feature_names





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ['X0', 'X1', 'X3']



.. GENERATED FROM PYTHON SOURCE LINES 56-57

Revert all feature selection

.. GENERATED FROM PYTHON SOURCE LINES 57-59

.. code-block:: Python

    ds.set_active_features(features=None) # by default, all features are set active
    ds.feature_names




.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ['X0', 'X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9']




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 6.194 seconds)


.. _sphx_glr_download__source_auto_galleries_data_plot_2_feature_selection.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_2_feature_selection.ipynb <plot_2_feature_selection.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_2_feature_selection.py <plot_2_feature_selection.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_2_feature_selection.zip <plot_2_feature_selection.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
